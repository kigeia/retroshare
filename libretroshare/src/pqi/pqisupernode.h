/*
 * "$Id: pqisupernode.h,v 1.2 2007-02-18 21:46:50 rmf24 Exp $"
 *
 * 3P/PQI network interface for RetroShare.
 *
 * Copyright 2004-2006 by Robert Fernie.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License Version 2 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
 * USA.
 *
 * Please report all bugs and problems to "retroshare@lunamutt.com".
 *
 */



#ifndef MRK_PQI_SUPER_NODE_HEADER
#define MRK_PQI_SUPER_NODE_HEADER

#include "pqi/pqihandler.h"
#include "pqi/pqiperson.h"
#include "pqi/pqitunnel.h"
#include "pqi/pqissllistener.h"

/*****************************************************************
 * So a super node, is a very special being, 
 * and used to assist in the setup of a retro share network.
 *
 * It role is to accept all connections, 
 * and allow discovery/proxying for facilitating connections.
 *
 * Therefore this interface includes
 * both a p3disc + p3udpproxy, but
 * doesn't allow any other traffic through....
 *
 * each person will only include a pqissl (generated by the listener).
 *
 * The tricky part is allowing the pqissl to be 
 * generated on the fly, as the connections are made!
 *
 */


class p3proxy;
class p3disc;

class pqiudplistener;
class pqisslsupernode;

class pqisupernode: public pqihandler, public PQTunnelServer
{
	public:
	pqisupernode(SecurityPolicy *, sslroot *sr);

	// overloaded from pqihandler -> null fns

	virtual int	Search(SearchItem *ns)  	{ if (ns) delete ns; return 1; }
	virtual int	CancelSearch(SearchItem *ns) 	{ if (ns) delete ns; return 1; }
	virtual int	SendSearchResult(PQFileItem *ns){ if (ns) delete ns; return 1; }

	// inputs.
	virtual PQFileItem * 	GetSearchResult() 	{ return NULL; }
	virtual SearchItem *	RequestedSearch() 	{ return NULL; }
	virtual SearchItem *	CancelledSearch() 	{ return NULL; }

	// file i/o
	virtual int     SendFileItem(PQFileItem *ns) 	{ if (ns) delete ns; return 1; }
	virtual PQFileItem *	GetFileItem() 		{ return NULL; }

	// Chat Interface
	virtual int     SendMsg(ChatItem *ns) 	     	{ if (ns) delete ns; return 1; }
	virtual ChatItem *GetMsg() 			{ return NULL; }

	// end of overloaded from pqihandler -> null fns


	// control the connections.
int	cert_accept(cert *a);
int	cert_deny(cert *a);
int	cert_auto(cert *a, bool b);

int	restart_listener();

int	save_config();
int	load_config();

	// tick interfaces.
virtual int run();
virtual int tick();
virtual int status();


	// the pqisslsupernode, is derived from the pqissllistener, 
	// except it doesn't track who it should listen for.
	// instead each connection is accepted blind, 
	// and passed to the pqisupernode. which can attach it
	// to a pqissl, if desired....
	//
	// The first basic version of this will accept up to a total 
	// limit......
virtual int recvdConnection(int fd, SSL *in_connection, 
                                cert *peer, struct sockaddr_in *raddr);



	// overloaded functions to disable various features of pqihandler

	// + SearchInterface which should automatically handle stuff

	// acess to services.
	p3disc *getP3Disc()   { return p3d; } 
	p3proxy *getP3Proxy() { return p3p; }

	protected:
	/* Overloaded PQItem Check
	 * checks item->cid vs Person
	 */
virtual int checkOutgoingPQItem(PQItem *item, int global);

	private:

	// The tunnelserver operation.
	int tickTunnelServer();

	pqisslsupernode *pqisslnode;
	pqiudplistener     *pqiudpl;

	sslroot *sslr;

	p3disc    *p3d;
	p3proxy   *p3p;
};



class pqisslsupernode: public pqissllistener
{
	public:

	pqisslsupernode(struct sockaddr_in addr, pqisupernode *grp);
virtual ~pqisslsupernode();

//virtual int 	tick();
//virtual int 	status();

virtual int completeConnection(int sockfd, SSL *in_connection, struct sockaddr_in &raddr);

	private:

	pqisupernode *psn;
};



#endif // MRK_PQI_SUPER_NODE_HEADER
